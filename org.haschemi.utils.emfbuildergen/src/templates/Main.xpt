«REM»
/*******************************************************************************
 * Copyright (c) 2010 - 2010 EMF Builder Generator project.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 * EMF Builder Generator project committers - initial API and implementation
 * Contact : siamak AT haschemi.org
 *******************************************************************************/
«ENDREM»
«IMPORT ecore»
«IMPORT emf»

«EXTENSION templates::extensions»
«EXTENSION org::eclipse::xtend::util::stdlib::io»

«DEFINE main FOR EPackage»
  «EXPAND ePackage»
«ENDDEFINE»

«DEFINE ePackage FOR EPackage»
  «EXPAND ePackage FOREACH eSubpackages» 
  «EXPAND builderFacade» 
  «EXPAND eClassifier FOREACH eClassifiers»
«ENDDEFINE»

«DEFINE builderFacade FOR EPackage»
  «FILE fqFacadeFile()»
    package «fqFacadeJavaPackage()»;
    
    /**
     * <!-- begin-user-doc --> 
     *   A facade for the builders for the EMF package ' <em><b>«nsURI»</b></em>'.
     * <!-- end-user-doc -->
     * 
     * @generated
     */
     public class «facadeName()» {
       «EXPAND builderAccessMethod FOREACH eClassifiers»
     }
  «ENDFILE»
«ENDDEFINE»

«DEFINE builderAccessMethod FOR EClassifier»
«ENDDEFINE»

«DEFINE builderAccessMethod FOR EClass»
  «IF isBuilderType()»
    public static final «builderName()» new«builderName()»() {
      return «builderName()».new«builderName()»();
    }
  «ENDIF»
«ENDDEFINE»

«DEFINE eClassifier FOR EClassifier» 
«ENDDEFINE»

«DEFINE eClassifier FOR EClass»
  «IF isBuilderType()»
    «FILE fqBuilderFile()»
      package «fqBuilderJavaPackage()»;
      
      /**
       * <!-- begin-user-doc --> 
       *   A builder for the model object ' <em><b>«fqGenJava()»</b></em>'.
       * <!-- end-user-doc -->
       * 
       * @generated
       */
      public class «builderName()» {
      
        // features and builders
        «EXPAND declaration FOREACH unaryStructuralFeatures()»
        «EXPAND declarationMulti FOREACH multipleStructuralFeatures()»
        
        // helper attributes
        «EXPAND assignmentHelperDeclaration FOREACH structuralFeatures()»        
      
        /**
         * Builder is not instantiated with a constructor.
         * @see #new«builderName()»()
         */ 
        private «builderName()»() {
        }
        
        /**
         * This method creates a new instance of the «builderName()».
         * @return new instance of the «builderName()»
         */
        public static «builderName()» new«builderName()»() {
          return new «builderName()»();
        }
        
        /**
         * This method can be used to override attributes of the builder. It constructs a new builder and copies the current values to it.
         */
        public «builderName()» but() {
          «LET "_builder" AS var»
            «builderName()» «var» = new«builderName()»();        
            «EXPAND assignBuilderFeatures(var) FOREACH structuralFeatures()»           
            return «var»;
          «ENDLET»            
        }
        
        /**
         * This method constructs the final «fqGenJava()» type.
         * @return new instance of the «fqGenJava()» type
         */
        public «fqGenJava()» build() {
          «LET "_newInstance" AS var»
            final «fqGenJava()» «var» = «fqGenJavaPackage()».«factoryInstance()».create«name.toFirstUpper()»();            
            «EXPAND assignFeatures(var) FOREACH unaryStructuralFeatures()»
            «EXPAND assignFeaturesMulti(var) FOREACH multipleStructuralFeatures()»            
            return «var»;
          «ENDLET»
        }    
        
        «EXPAND method(this) FOREACH unaryStructuralFeatures()»
        «EXPAND methodMulti(this) FOREACH multipleStructuralFeatures()»
      }
    «ENDFILE»
  «ENDIF»
«ENDDEFINE»

«DEFINE declaration FOR EStructuralFeature»
  private «EXPAND typeDeclaration FOR eType» m_«safeName()»;
  «IF eType.isBuilderType()»
    private «eType.fqBuilderJava()» m_feature«safeName().toFirstUpper()»Builder;   
  «ENDIF»
«ENDDEFINE»

«DEFINE declarationMulti FOR EStructuralFeature»
  private java.util.Collection<«EXPAND typeDeclaration FOR eType»> m_«safeName()» = new java.util.LinkedList<«EXPAND typeDeclaration FOR eType»>();
  «IF eType.isBuilderType()»
    private java.util.Collection<«eType.fqBuilderJava()»> m_feature«safeName().toFirstUpper()»Builder = new java.util.LinkedList<«eType.fqBuilderJava()»>();   
  «ENDIF»
«ENDDEFINE»

«DEFINE typeDeclaration FOR ETypedElement»
  «throwRuntimeException("Unmapped Element '" + this + "' in typeDeclaration")»
«ENDDEFINE»

«DEFINE typeDeclaration FOR EClassifier»
   «IF instanceClassName != null»
    «instanceClassName.toJavaRef()»
  «ELSE»
    «fqGenJava()»
  «ENDIF»
«ENDDEFINE»

«DEFINE typeDeclaration FOR EClass»  
  «IF instanceClassName == null»
    «fqGenJava()»
  «ELSE»     
    «instanceClassName.toJavaRef()»
    «REM»handle special case in Ecore metamodel, where a map is used. Maybe there is a general mechanism we do not understand, yet.«ENDREM»
    «IF instanceClassName == "java.util.Map$Entry" && !structuralFeatures().isEmpty»
      <«FOREACH structuralFeatures() AS sf SEPARATOR ","»
        «EXPAND typeDeclaration FOR sf.eType»
      «ENDFOREACH»>
    «ENDIF»    
  «ENDIF»
«ENDDEFINE»

«DEFINE assignmentHelperDeclaration FOR EStructuralFeature»
  private boolean m_feature«safeName().toFirstUpper()»Set = false;
«ENDDEFINE»

«DEFINE assignBuilderFeatures(String p_var) FOR EStructuralFeature»
  «p_var».m_feature«safeName().toFirstUpper()»Set = m_feature«safeName().toFirstUpper()»Set;
  «p_var».m_«safeName()» = m_«safeName()»;
  «IF eType.isBuilderType()»
    «p_var».m_feature«safeName().toFirstUpper()»Builder = m_feature«safeName().toFirstUpper()»Builder;
  «ENDIF»
«ENDDEFINE»

«DEFINE assignFeatures(String p_var) FOR EStructuralFeature»
  if(m_feature«safeName().toFirstUpper()»Set) {
    «p_var».set«safeSetterName().toFirstUpper()»(m_«safeName()»);     
  «IF eType.isBuilderType()»
  } else {
    if (m_feature«safeName().toFirstUpper()»Builder != null) {
      «p_var».set«safeSetterName().toFirstUpper()»(m_feature«safeName().toFirstUpper()»Builder.build());
    }    
  }
  «ELSE»
  }
  «ENDIF»
«ENDDEFINE»

«DEFINE assignFeaturesMulti(String p_var) FOR EStructuralFeature»
  if(m_feature«safeName().toFirstUpper()»Set) {    
    «p_var».get«potentiallyPluralizedName().toFirstUpper()»().addAll(m_«safeName()»);        
  «IF eType.isBuilderType()»
  } else {
    if (!m_feature«safeName().toFirstUpper()»Builder.isEmpty()) {
      for («eType.builderName()» builder: m_feature«safeName().toFirstUpper()»Builder) {
         «p_var».get«potentiallyPluralizedName().toFirstUpper()»().add(builder.build());          
      }
    } 
  }
  «ELSE»
  }
  «ENDIF»
«ENDDEFINE»

«DEFINE method(EClass p_context) FOR EStructuralFeature»  
  public «p_context.builderName()» «featureAccessMethod()»(«EXPAND typeDeclaration FOR eType» p_«safeName()»){
    m_«safeName()» = p_«safeName()»;
    m_feature«safeName().toFirstUpper()»Set = true;
    return this;
  }

  «IF eType.isBuilderType()»
    public «p_context.builderName()» «featureAccessMethod()»(«eType.fqBuilderJava()» p_«eType.builderName().toFirstLower()»){
      m_feature«safeName().toFirstUpper()»Builder = p_«eType.builderName().toFirstLower()»;
      return this;
    }
  «ENDIF»  
«ENDDEFINE»

«DEFINE methodMulti(EClass p_context) FOR EStructuralFeature» 
  public «p_context.builderName()» «featureAccessMethod()»(«EXPAND typeDeclaration FOR eType» p_«safeName()»){
    m_«safeName()».add(p_«safeName()»);
    m_feature«safeName().toFirstUpper()»Set = true;
    return this;
  }    

  public «p_context.builderName()» «featureAccessMethod()»(java.util.Collection<? extends «EXPAND typeDeclaration FOR eType»> p_«safeName()»){
    m_«safeName()».addAll(p_«safeName()»);
    m_feature«safeName().toFirstUpper()»Set = true;
    return this;
  }

  «IF eType.isBuilderType()»
    public «p_context.builderName()» «featureAccessMethod()»(«eType.builderName()» p_«eType.builderName().toFirstLower()»){
      m_feature«safeName().toFirstUpper()»Builder.add(p_«eType.builderName().toFirstLower()»);
      return this;
    }            
  «ENDIF»  
«ENDDEFINE»
